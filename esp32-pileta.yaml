esphome:
  name: esp32-pileta
  friendly_name: ESP32-pileta

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "TkVr/h9aAttsFad49ShvWFRfdA6NGtCM2BCE7R4sFxg="

ota:
  - platform: esphome
    password: "e07a33a39b7e3fca2685b424524718b6"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Esp32-Pileta Fallback Hotspot"
    password: "KHIUDZeptBI2"

captive_portal:

mqtt:
  broker: "192.168.1.8"

# Time synchronization from Home Assistant
time:
  - platform: homeassistant
    id: ha_time
    on_time:
      # Reset daily counter at midnight
      - seconds: 0
        minutes: 0
        hours: 0
        then:
          - lambda: |-
              ESP_LOGI("runtime_tracker", "Reset diario: %.2f horas registradas ayer", id(bomba_horas_hoy));
              id(bomba_horas_hoy) = 0.0;

one_wire:
  - platform: gpio
    pin: GPIO25

sensor:
  - platform: dallas_temp
    address: 0xd81c77d446f18a28
    name: "temperatura agua"
    update_interval: 30s
    id: temperatura_agua
    on_value:
      then:
        - lambda: |-
            id(temp_agua_last_update) = millis();
        - mqtt.publish:
            topic: "pool_heat/temp/water"
            payload: !lambda |-
              return String(id(temperatura_agua).state).c_str();


  - platform: dallas_temp
    address: 0x65011447d4f2aa28
    name: "temperatura caja techo"
    update_interval: 30s
    id: temperatura_caja
    on_value:
      then:
        - mqtt.publish:
            topic: "pool_heat/temp/roof"
            payload: !lambda |-
              return String(id(temperatura_caja).state).c_str();

  - platform: dallas_temp
    address: 0xe0011448ab01aa28
    name: "temperatura calefactor"
    update_interval: 30s
    id: temperatura_calefactor
    on_value:
      then:
        - lambda: |-
            id(temp_calefactor_last_update) = millis();
        - mqtt.publish:
            topic: "pool_heat/temp/heater"
            payload: !lambda |-
              return String(id(temperatura_calefactor).state).c_str();

  - platform: adc
    pin: GPIO32
    name: "Iluminacion techo"
    update_interval: 60s
    id: iluminacion_techo
    on_value:
      then:
        - mqtt.publish:
            topic: "pool_heat/ligth/roof"
            payload: !lambda |-
              return String(id(iluminacion_techo).state).c_str();

  - platform: wifi_signal
    name: "Señal WiFi ESP32 Pileta"
    update_interval: 60s

  # Runtime tracking sensor
  - platform: template
    name: "Horas Bomba Hoy"
    id: sensor_horas_bomba_hoy
    unit_of_measurement: "h"
    accuracy_decimals: 1
    update_interval: 60s
    lambda: 'return id(bomba_horas_hoy);'

  # Home Assistant Input Entities - Configuration parameters
  - platform: homeassistant
    id: ha_temp_objetivo
    entity_id: input_number.pileta_temp_objetivo
    name: "HA Temperatura Objetivo (ITO)"
    on_value:
      then:
        - globals.set:
            id: temp_objetivo
            value: !lambda 'return x;'
        - logger.log:
            format: "Temperatura objetivo actualizada: %.1f°C"
            args: ['x']

  - platform: homeassistant
    id: ha_temp_max_diff
    entity_id: input_number.pileta_temp_max_diff
    name: "HA Temp Max Diff (IMX)"
    on_value:
      then:
        - lambda: |-
            float new_max_diff = x;
            float current_min_diff = id(temp_min_diff);
            float min_allowed = current_min_diff + 1.0;

            if (new_max_diff < min_allowed) {
              ESP_LOGW("safety", "IMX (%.1f) < IMI + 1 (%.1f). Forzando IMX = %.1f",
                       new_max_diff, min_allowed, min_allowed);
              id(temp_max_diff) = min_allowed;
            } else {
              id(temp_max_diff) = new_max_diff;
            }

            ESP_LOGI("config", "Diferencia máxima actualizada: %.1f°C", id(temp_max_diff));

  - platform: homeassistant
    id: ha_temp_min_diff
    entity_id: input_number.pileta_temp_min_diff
    name: "HA Temp Min Diff (IMI)"
    on_value:
      then:
        - lambda: |-
            float new_min_diff = x;
            float current_max_diff = id(temp_max_diff);

            // Update IMI
            id(temp_min_diff) = new_min_diff;
            ESP_LOGI("config", "Diferencia mínima actualizada: %.1f°C", new_min_diff);

            // Check if IMX needs adjustment
            float min_allowed_max = new_min_diff + 1.0;
            if (current_max_diff < min_allowed_max) {
              ESP_LOGW("safety", "IMX (%.1f) < IMI + 1 (%.1f). Forzando IMX = %.1f",
                       current_max_diff, min_allowed_max, min_allowed_max);
              id(temp_max_diff) = min_allowed_max;
              ESP_LOGI("config", "Diferencia máxima ajustada a: %.1f°C", id(temp_max_diff));
            }

# Text sensor for boolean input from HA
text_sensor:
  - platform: homeassistant
    id: ha_activar_calefaccion
    entity_id: input_boolean.activar_calefaccion_pileta
    name: "HA Activar Calefaccion (IAC)"
    on_value:
      then:
        - globals.set:
            id: calefaccion_habilitada
            value: !lambda |-
              return (x == "on" || x == "true");
        - logger.log:
            format: "Calefacción habilitada: %s"
            args: ['x.c_str()']

# Global variables to store last known values for offline operation
globals:
  - id: calefaccion_habilitada
    type: bool
    restore_value: yes
    initial_value: 'false'

  - id: temp_objetivo
    type: float
    restore_value: yes
    initial_value: '28.0'

  - id: temp_max_diff
    type: float
    restore_value: yes
    initial_value: '5.0'

  - id: temp_min_diff
    type: float
    restore_value: yes
    initial_value: '2.0'

  - id: bomba_modo_calefaccion
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: bomba_horas_hoy
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: temp_agua_last_update
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: temp_calefactor_last_update
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: heating_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'


# Control logic - Evaluate heating conditions every 30 seconds
interval:
  - interval: 30s
    then:
      - lambda: |-
          // Get current values
          bool habilitada = id(calefaccion_habilitada);
          float temp_agua = id(temperatura_agua).state;
          float temp_calefactor = id(temperatura_calefactor).state;
          float objetivo = id(temp_objetivo);
          float max_diff = id(temp_max_diff);
          float min_diff = id(temp_min_diff);
          bool calefaccion_on = id(pileta_calefaccion_completa).state;
          unsigned long current_time = millis();

          // SAFETY CHECK 1: Check if we have valid sensor readings (NaN)
          if (isnan(temp_agua) || isnan(temp_calefactor)) {
            ESP_LOGW("safety", "Sensores no disponibles - esperando lecturas");
            if (calefaccion_on) {
              ESP_LOGE("safety", "Apagando calefacción por sensores inválidos");
              id(pileta_calefaccion_completa).turn_off();
            }
            return;
          }

          // SAFETY CHECK 2: Sensor range validation
          if (temp_agua < 0.0 || temp_agua > 50.0) {
            ESP_LOGE("safety", "Temperatura agua fuera de rango: %.1f°C", temp_agua);
            if (calefaccion_on) {
              ESP_LOGE("safety", "Apagando calefacción por sensor agua inválido");
              id(pileta_calefaccion_completa).turn_off();
            }
            return;
          }
          if (temp_calefactor < 0.0 || temp_calefactor > 80.0) {
            ESP_LOGE("safety", "Temperatura calefactor fuera de rango: %.1f°C", temp_calefactor);
            if (calefaccion_on) {
              ESP_LOGE("safety", "Apagando calefacción por sensor calefactor inválido");
              id(pileta_calefaccion_completa).turn_off();
            }
            return;
          }

          // SAFETY CHECK 3: Sensor staleness detection (5 minutes = 300000ms)
          if (id(temp_agua_last_update) > 0 &&
              (current_time - id(temp_agua_last_update)) > 300000) {
            ESP_LOGE("safety", "Sensor agua sin actualizar por >5 min");
            if (calefaccion_on) {
              ESP_LOGE("safety", "Apagando calefacción por sensor agua obsoleto");
              id(pileta_calefaccion_completa).turn_off();
            }
            return;
          }
          if (id(temp_calefactor_last_update) > 0 &&
              (current_time - id(temp_calefactor_last_update)) > 300000) {
            ESP_LOGE("safety", "Sensor calefactor sin actualizar por >5 min");
            if (calefaccion_on) {
              ESP_LOGE("safety", "Apagando calefacción por sensor calefactor obsoleto");
              id(pileta_calefaccion_completa).turn_off();
            }
            return;
          }

          // SAFETY CHECK 4: Pump state desync detection
          if (calefaccion_on && (!id(pileta_bomba_esp).state || !id(pileta_calefaccion_esp).state)) {
            ESP_LOGE("safety", "Desincronización detectada! Bomba=%s, Calefactor=%s",
                     id(pileta_bomba_esp).state ? "ON" : "OFF",
                     id(pileta_calefaccion_esp).state ? "ON" : "OFF");
            ESP_LOGE("safety", "Apagando sistema completo");
            id(pileta_calefaccion_completa).turn_off();
            return;
          }

          // SAFETY CHECK 5: Independent runtime watchdog (8 hours = 28800000ms)
          if (calefaccion_on && id(heating_start_time) > 0) {
            unsigned long runtime = current_time - id(heating_start_time);
            if (runtime > 28800000) {
              ESP_LOGE("safety", "Watchdog: 8 horas de operación alcanzadas");
              ESP_LOGE("safety", "Apagando por límite de tiempo independiente");
              id(pileta_calefaccion_completa).turn_off();
              return;
            }
          }

          ESP_LOGD("control_logic", "Estado: IAC=%s, SAG=%.1f°C, SCL=%.1f°C, ITO=%.1f°C, IMX=%.1f°C, IMI=%.1f°C, Calef=%s",
                   habilitada ? "ON" : "OFF",
                   temp_agua,
                   temp_calefactor,
                   objetivo,
                   max_diff,
                   min_diff,
                   calefaccion_on ? "ON" : "OFF");

          // Turn OFF conditions (ANY condition triggers stop)
          bool should_turn_off = false;

          if (!habilitada) {
            ESP_LOGI("control_logic", "Apagar: IAC deshabilitada");
            should_turn_off = true;
          } else if (temp_agua >= objetivo) {
            ESP_LOGI("control_logic", "Apagar: Temperatura objetivo alcanzada (%.1f >= %.1f)", temp_agua, objetivo);
            should_turn_off = true;
          } else if (temp_calefactor <= (temp_agua + min_diff)) {
            ESP_LOGI("control_logic", "Apagar: Calefactor insuficiente (%.1f <= %.1f + %.1f)",
                     temp_calefactor, temp_agua, min_diff);
            should_turn_off = true;
          }

          if (should_turn_off && calefaccion_on) {
            ESP_LOGI("control_logic", ">>> APAGANDO CALEFACCION <<<");
            id(pileta_calefaccion_completa).turn_off();
            return;
          }

          // Turn ON conditions (ALL conditions must be true)
          bool should_turn_on = false;

          if (habilitada &&
              temp_agua < (objetivo - 0.5) &&  // Dead zone of 0.5°C
              temp_calefactor > (temp_agua + max_diff)) {
            should_turn_on = true;
            ESP_LOGI("control_logic", "Condiciones para encender cumplidas:");
            ESP_LOGI("control_logic", "  - IAC habilitada: SI");
            ESP_LOGI("control_logic", "  - SAG < (ITO - 0.5): %.1f < %.1f = SI", temp_agua, objetivo - 0.5);
            ESP_LOGI("control_logic", "  - SCL > (SAG + IMX): %.1f > %.1f = SI", temp_calefactor, temp_agua + max_diff);
          }

          if (should_turn_on && !calefaccion_on) {
            ESP_LOGI("control_logic", ">>> ENCENDIENDO CALEFACCION <<<");
            id(pileta_calefaccion_completa).turn_on();
            return;
          }

          // Log reason for not changing state
          if (!habilitada) {
            ESP_LOGD("control_logic", "No cambio: IAC deshabilitada");
          } else if (calefaccion_on) {
            ESP_LOGD("control_logic", "No cambio: Calefaccion ya encendida, condiciones para apagar no cumplidas");
          } else if (temp_agua >= (objetivo - 0.5)) {
            ESP_LOGD("control_logic", "No cambio: Temperatura cerca del objetivo (%.1f >= %.1f)",
                     temp_agua, objetivo - 0.5);
          } else if (temp_calefactor <= (temp_agua + max_diff)) {
            ESP_LOGD("control_logic", "No cambio: Calefactor insuficiente (%.1f <= %.1f)",
                     temp_calefactor, temp_agua + max_diff);
          }

  # Runtime tracking - Update pump hours counter every minute
  - interval: 60s
    then:
      - lambda: |-
          if (id(pileta_bomba_esp).state) {
            id(bomba_horas_hoy) += (1.0 / 60.0);  // Add 1/60 hour = 1 minute
            ESP_LOGD("runtime_tracker", "Bomba horas hoy: %.2f", id(bomba_horas_hoy));
          }

switch:
  - platform: gpio
    pin: GPIO2
    name: "Bomba pileta (ESP32)"
    id: pileta_bomba_esp
    on_turn_on:
      then:
        - logger.log: "Bomba pileta encendida - Temporizador 1 hora iniciado"
        - delay: 1h
        - if:
            condition:
              lambda: 'return !id(bomba_modo_calefaccion);'
            then:
              - switch.turn_off: pileta_bomba_esp
              - logger.log: "Bomba pileta apagada automáticamente después de 1 hora (modo skimmer)"
            else:
              - logger.log: "Auto-apagado de bomba omitido: controlada por modo calefacción"

  - platform: gpio
    pin: GPIO16
    name: "Calefaccion pileta (ESP32)"
    id: pileta_calefaccion_esp
    on_turn_on:
      then:
        - delay: 8h
        - switch.turn_off: pileta_calefaccion_esp
        - logger.log: "pileta_calefaccion_esp apagado automáticamente después de 8 horas."

  # Switch virtual: Modo calefacción (ambas bombas)
  - platform: template
    name: "Calefaccion Completa (ESP32)"
    id: pileta_calefaccion_completa
    lambda: |-
      // El switch está ON solo si AMBAS bombas están encendidas
      if (id(pileta_bomba_esp).state && id(pileta_calefaccion_esp).state) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - globals.set:
          id: bomba_modo_calefaccion
          value: 'true'
      - lambda: |-
          id(heating_start_time) = millis();
          ESP_LOGI("safety", "Watchdog iniciado - límite 8 horas");
      - logger.log: "Modo calefacción: activando flag de control"
      - switch.turn_on: pileta_bomba_esp
      - switch.turn_on: pileta_calefaccion_esp
      - logger.log: "Modo calefacción activado: ambas bombas encendidas"
      - delay: 8h
      - switch.turn_off: pileta_bomba_esp
      - switch.turn_off: pileta_calefaccion_esp
      - globals.set:
          id: bomba_modo_calefaccion
          value: 'false'
      - lambda: |-
          id(heating_start_time) = 0;
      - logger.log: "Modo calefacción apagado automáticamente después de 8 horas"
    turn_off_action:
      - globals.set:
          id: bomba_modo_calefaccion
          value: 'false'
      - lambda: |-
          id(heating_start_time) = 0;
      - logger.log: "Modo calefacción: desactivando flag de control"
      - switch.turn_off: pileta_bomba_esp
      - switch.turn_off: pileta_calefaccion_esp
      - logger.log: "Modo calefacción desactivado manualmente"
