esphome:
  name: esp32-pileta
  friendly_name: ESP32-pileta

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "TkVr/h9aAttsFad49ShvWFRfdA6NGtCM2BCE7R4sFxg="

ota:
  - platform: esphome
    password: "e07a33a39b7e3fca2685b424524718b6"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Esp32-Pileta Fallback Hotspot"
    password: "KHIUDZeptBI2"

captive_portal:
  
mqtt:
  broker: "192.168.1.8"

one_wire:
  - platform: gpio
    pin: GPIO25

sensor:
  - platform: dallas_temp
    address: 0xd81c77d446f18a28
    name: "temperatura agua"
    update_interval: 30s
    id: temperatura_agua
    on_value:
      then:
        - mqtt.publish:
            topic: "pool_heat/temp/water"
            payload: !lambda |-
              return String(id(temperatura_agua).state).c_str();


  - platform: dallas_temp
    address: 0x65011447d4f2aa28
    name: "temperatura caja techo"
    update_interval: 30s
    id: temperatura_caja
    on_value:
      then:
        - mqtt.publish:
            topic: "pool_heat/temp/roof"
            payload: !lambda |-
              return String(id(temperatura_caja).state).c_str();

  - platform: dallas_temp
    address: 0xe0011448ab01aa28 
    name: "temperatura calefactor"
    update_interval: 30s
    id: temperatura_calefactor
    on_value:
      then:
        - mqtt.publish:
            topic: "pool_heat/temp/heater"
            payload: !lambda |-
              return String(id(temperatura_calefactor).state).c_str();

  - platform: adc
    pin: GPIO32
    name: "Iluminacion techo"
    update_interval: 60s
    id: iluminacion_techo
    on_value:
      then:
        - mqtt.publish:
            topic: "pool_heat/ligth/roof"
            payload: !lambda |-
              return String(id(iluminacion_techo).state).c_str();

  - platform: wifi_signal
    name: "Señal WiFi ESP32 Pileta"
    update_interval: 60s

  # Home Assistant Input Entities - Configuration parameters
  - platform: homeassistant
    id: ha_temp_objetivo
    entity_id: input_number.pileta_temp_objetivo
    name: "HA Temperatura Objetivo (ITO)"
    on_value:
      then:
        - globals.set:
            id: temp_objetivo
            value: !lambda 'return x;'
        - logger.log:
            format: "Temperatura objetivo actualizada: %.1f°C"
            args: ['x']

  - platform: homeassistant
    id: ha_temp_max_diff
    entity_id: input_number.pileta_temp_max_diff
    name: "HA Temp Max Diff (IMX)"
    on_value:
      then:
        - globals.set:
            id: temp_max_diff
            value: !lambda 'return x;'
        - logger.log:
            format: "Diferencia máxima actualizada: %.1f°C"
            args: ['x']

  - platform: homeassistant
    id: ha_temp_min_diff
    entity_id: input_number.pileta_temp_min_diff
    name: "HA Temp Min Diff (IMI)"
    on_value:
      then:
        - globals.set:
            id: temp_min_diff
            value: !lambda 'return x;'
        - logger.log:
            format: "Diferencia mínima actualizada: %.1f°C"
            args: ['x']

# Text sensor for boolean input from HA
text_sensor:
  - platform: homeassistant
    id: ha_activar_calefaccion
    entity_id: input_boolean.activar_calefaccion_pileta
    name: "HA Activar Calefaccion (IAC)"
    on_value:
      then:
        - globals.set:
            id: calefaccion_habilitada
            value: !lambda |-
              return (x == "on" || x == "true");
        - logger.log:
            format: "Calefacción habilitada: %s"
            args: ['x.c_str()']

# Global variables to store last known values for offline operation
globals:
  - id: calefaccion_habilitada
    type: bool
    restore_value: yes
    initial_value: 'false'

  - id: temp_objetivo
    type: float
    restore_value: yes
    initial_value: '28.0'

  - id: temp_max_diff
    type: float
    restore_value: yes
    initial_value: '5.0'

  - id: temp_min_diff
    type: float
    restore_value: yes
    initial_value: '2.0'

  - id: bomba_modo_calefaccion
    type: bool
    restore_value: no
    initial_value: 'false'


# Control logic - Evaluate heating conditions every 30 seconds
interval:
  - interval: 30s
    then:
      - lambda: |-
          // Get current values
          bool habilitada = id(calefaccion_habilitada);
          float temp_agua = id(temperatura_agua).state;
          float temp_calefactor = id(temperatura_calefactor).state;
          float objetivo = id(temp_objetivo);
          float max_diff = id(temp_max_diff);
          float min_diff = id(temp_min_diff);
          bool calefaccion_on = id(pileta_calefaccion_completa).state;

          // Check if we have valid sensor readings
          if (isnan(temp_agua) || isnan(temp_calefactor)) {
            ESP_LOGW("control_logic", "Sensores no disponibles - esperando lecturas");
            return;
          }

          ESP_LOGD("control_logic", "Estado: IAC=%s, SAG=%.1f°C, SCL=%.1f°C, ITO=%.1f°C, IMX=%.1f°C, IMI=%.1f°C, Calef=%s",
                   habilitada ? "ON" : "OFF",
                   temp_agua,
                   temp_calefactor,
                   objetivo,
                   max_diff,
                   min_diff,
                   calefaccion_on ? "ON" : "OFF");

          // Turn OFF conditions (ANY condition triggers stop)
          bool should_turn_off = false;

          if (!habilitada) {
            ESP_LOGI("control_logic", "Apagar: IAC deshabilitada");
            should_turn_off = true;
          } else if (temp_agua >= objetivo) {
            ESP_LOGI("control_logic", "Apagar: Temperatura objetivo alcanzada (%.1f >= %.1f)", temp_agua, objetivo);
            should_turn_off = true;
          } else if (temp_calefactor <= (temp_agua + min_diff)) {
            ESP_LOGI("control_logic", "Apagar: Calefactor insuficiente (%.1f <= %.1f + %.1f)",
                     temp_calefactor, temp_agua, min_diff);
            should_turn_off = true;
          }

          if (should_turn_off && calefaccion_on) {
            ESP_LOGI("control_logic", ">>> APAGANDO CALEFACCION <<<");
            id(pileta_calefaccion_completa).turn_off();
            return;
          }

          // Turn ON conditions (ALL conditions must be true)
          bool should_turn_on = false;

          if (habilitada &&
              temp_agua < (objetivo - 0.5) &&  // Dead zone of 0.5°C
              temp_calefactor > (temp_agua + max_diff)) {
            should_turn_on = true;
            ESP_LOGI("control_logic", "Condiciones para encender cumplidas:");
            ESP_LOGI("control_logic", "  - IAC habilitada: SI");
            ESP_LOGI("control_logic", "  - SAG < (ITO - 0.5): %.1f < %.1f = SI", temp_agua, objetivo - 0.5);
            ESP_LOGI("control_logic", "  - SCL > (SAG + IMX): %.1f > %.1f = SI", temp_calefactor, temp_agua + max_diff);
          }

          if (should_turn_on && !calefaccion_on) {
            ESP_LOGI("control_logic", ">>> ENCENDIENDO CALEFACCION <<<");
            id(pileta_calefaccion_completa).turn_on();
            return;
          }

          // Log reason for not changing state
          if (!habilitada) {
            ESP_LOGD("control_logic", "No cambio: IAC deshabilitada");
          } else if (calefaccion_on) {
            ESP_LOGD("control_logic", "No cambio: Calefaccion ya encendida, condiciones para apagar no cumplidas");
          } else if (temp_agua >= (objetivo - 0.5)) {
            ESP_LOGD("control_logic", "No cambio: Temperatura cerca del objetivo (%.1f >= %.1f)",
                     temp_agua, objetivo - 0.5);
          } else if (temp_calefactor <= (temp_agua + max_diff)) {
            ESP_LOGD("control_logic", "No cambio: Calefactor insuficiente (%.1f <= %.1f)",
                     temp_calefactor, temp_agua + max_diff);
          }

switch:
  - platform: gpio
    pin: GPIO2
    name: "Bomba pileta (ESP32)"
    id: pileta_bomba_esp
    on_turn_on:
      then:
        - logger.log: "Bomba pileta encendida - Temporizador 1 hora iniciado"
        - delay: 1h
        - if:
            condition:
              lambda: 'return !id(bomba_modo_calefaccion);'
            then:
              - switch.turn_off: pileta_bomba_esp
              - logger.log: "Bomba pileta apagada automáticamente después de 1 hora (modo skimmer)"
            else:
              - logger.log: "Auto-apagado de bomba omitido: controlada por modo calefacción"

  - platform: gpio
    pin: GPIO16
    name: "Calefaccion pileta (ESP32)"
    id: pileta_calefaccion_esp
    on_turn_on:
      then:
        - delay: 8h
        - switch.turn_off: pileta_calefaccion_esp
        - logger.log: "pileta_calefaccion_esp apagado automáticamente después de 8 horas."

  # Switch virtual: Modo calefacción (ambas bombas)
  - platform: template
    name: "Calefaccion Completa (ESP32)"
    id: pileta_calefaccion_completa
    lambda: |-
      // El switch está ON solo si AMBAS bombas están encendidas
      if (id(pileta_bomba_esp).state && id(pileta_calefaccion_esp).state) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - globals.set:
          id: bomba_modo_calefaccion
          value: 'true'
      - logger.log: "Modo calefacción: activando flag de control"
      - switch.turn_on: pileta_bomba_esp
      - switch.turn_on: pileta_calefaccion_esp
      - logger.log: "Modo calefacción activado: ambas bombas encendidas"
      - delay: 8h
      - switch.turn_off: pileta_bomba_esp
      - switch.turn_off: pileta_calefaccion_esp
      - globals.set:
          id: bomba_modo_calefaccion
          value: 'false'
      - logger.log: "Modo calefacción apagado automáticamente después de 8 horas"
    turn_off_action:
      - globals.set:
          id: bomba_modo_calefaccion
          value: 'false'
      - logger.log: "Modo calefacción: desactivando flag de control"
      - switch.turn_off: pileta_bomba_esp
      - switch.turn_off: pileta_calefaccion_esp
      - logger.log: "Modo calefacción desactivado manualmente"
