esphome:
  name: esp32-pileta
  friendly_name: ESP32-pileta

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "TkVr/h9aAttsFad49ShvWFRfdA6NGtCM2BCE7R4sFxg="

ota:
  - platform: esphome
    password: "e07a33a39b7e3fca2685b424524718b6"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Esp32-Pileta Fallback Hotspot"
    password: "KHIUDZeptBI2"

captive_portal:

mqtt:
  broker: "192.168.1.8"

# Time synchronization from Home Assistant
time:
  - platform: homeassistant
    id: ha_time
    on_time_sync:
      then:
        - lambda: |-
            if (!id(time_synced)) {
              ESP_LOGI("skimmer", "Tiempo sincronizado con Home Assistant");
              id(time_synced) = true;
              id(skimmer_last_run) = 0;  // Disable fallback mode
            }
    on_time:
      # Reset daily counter at midnight
      - seconds: 0
        minutes: 0
        hours: 0
        then:
          - lambda: |-
              ESP_LOGI("runtime_tracker", "Reset diario: %.2f horas registradas hoy", id(bomba_horas_hoy));
              id(bomba_horas_ayer) = id(bomba_horas_hoy);
              ESP_LOGI("runtime_tracker", "Horas ayer almacenadas: %.2f", id(bomba_horas_ayer));
              id(bomba_horas_hoy) = 0.0;

              // Reset notification throttle flags
              id(notif_sensor_water_range_sent) = false;
              id(notif_sensor_heater_range_sent) = false;
              id(notif_sensor_water_stale_sent) = false;
              id(notif_sensor_heater_stale_sent) = false;
              id(notif_pump_desync_sent) = false;
              id(notif_watchdog_sent) = false;
              id(notif_param_validation_sent) = false;
              id(notif_test_available) = true;
              ESP_LOGI("notifications", "Flags de notificación reseteados");

      # Skimmer 7:00 trigger
      - seconds: 0
        minutes: 0
        hours: 7
        then:
          - lambda: |-
              ESP_LOGI("skimmer", "=== Trigger 7:00 - Verificando condiciones ===");

              // Check if time is synced
              if (!id(time_synced)) {
                ESP_LOGW("skimmer", "7:00 - Omitido: tiempo no sincronizado");
                return;
              }

              // Check if skimmer is enabled
              if (!id(skimmer_habilitado)) {
                ESP_LOGI("skimmer", "7:00 - Omitido: skimmer deshabilitado (IAS=OFF)");
                return;
              }

              // Check if heating is active
              if (id(bomba_modo_calefaccion)) {
                ESP_LOGI("skimmer", "7:00 - Omitido: calefacción activa (prioridad)");
                return;
              }

              // Check yesterday's runtime
              float horas_ayer = id(bomba_horas_ayer);
              if (horas_ayer > 3.0) {
                ESP_LOGI("skimmer", "7:00 - Omitido: bomba corrió %.2f horas ayer (> 3.0h)", horas_ayer);
                return;
              }

              // All conditions met - start pump
              ESP_LOGI("skimmer", "7:00 - INICIANDO bomba: horas ayer=%.2f <= 3.0", horas_ayer);
              id(pileta_bomba_esp).turn_on();

      # Skimmer 20:00 trigger
      - seconds: 0
        minutes: 0
        hours: 20
        then:
          - lambda: |-
              ESP_LOGI("skimmer", "=== Trigger 20:00 - Verificando condiciones ===");

              // Check if time is synced
              if (!id(time_synced)) {
                ESP_LOGW("skimmer", "20:00 - Omitido: tiempo no sincronizado");
                return;
              }

              // Check if skimmer is enabled
              if (!id(skimmer_habilitado)) {
                ESP_LOGI("skimmer", "20:00 - Omitido: skimmer deshabilitado (IAS=OFF)");
                return;
              }

              // Check if heating is active
              if (id(bomba_modo_calefaccion)) {
                ESP_LOGI("skimmer", "20:00 - Omitido: calefacción activa (prioridad)");
                return;
              }

              // Check today's runtime
              float horas_hoy = id(bomba_horas_hoy);
              if (horas_hoy > 2.5) {
                ESP_LOGI("skimmer", "20:00 - Omitido: bomba corrió %.2f horas hoy (> 2.5h)", horas_hoy);
                return;
              }

              // All conditions met - start pump
              ESP_LOGI("skimmer", "20:00 - INICIANDO bomba: horas hoy=%.2f <= 2.5", horas_hoy);
              id(pileta_bomba_esp).turn_on();

one_wire:
  - platform: gpio
    pin: GPIO25

sensor:
  - platform: dallas_temp
    address: 0xd81c77d446f18a28
    name: "temperatura agua"
    update_interval: 30s
    id: temperatura_agua
    on_value:
      then:
        - lambda: |-
            id(temp_agua_last_update) = millis();
        - mqtt.publish:
            topic: "pool_heat/temp/water"
            payload: !lambda |-
              return String(id(temperatura_agua).state).c_str();


  - platform: dallas_temp
    address: 0x65011447d4f2aa28
    name: "temperatura caja techo"
    update_interval: 30s
    id: temperatura_caja
    on_value:
      then:
        - mqtt.publish:
            topic: "pool_heat/temp/roof"
            payload: !lambda |-
              return String(id(temperatura_caja).state).c_str();

  - platform: dallas_temp
    address: 0xe0011448ab01aa28
    name: "temperatura calefactor"
    update_interval: 30s
    id: temperatura_calefactor
    on_value:
      then:
        - lambda: |-
            id(temp_calefactor_last_update) = millis();
        - mqtt.publish:
            topic: "pool_heat/temp/heater"
            payload: !lambda |-
              return String(id(temperatura_calefactor).state).c_str();

  - platform: adc
    pin: GPIO32
    name: "Iluminacion techo"
    update_interval: 60s
    id: iluminacion_techo
    on_value:
      then:
        - mqtt.publish:
            topic: "pool_heat/ligth/roof"
            payload: !lambda |-
              return String(id(iluminacion_techo).state).c_str();

  - platform: wifi_signal
    name: "Señal WiFi ESP32 Pileta"
    update_interval: 60s

  # Runtime tracking sensors
  - platform: template
    name: "Horas Bomba Hoy"
    id: sensor_horas_bomba_hoy
    unit_of_measurement: "h"
    accuracy_decimals: 1
    update_interval: 60s
    lambda: 'return id(bomba_horas_hoy);'

  - platform: template
    name: "Horas Bomba Ayer"
    id: sensor_horas_bomba_ayer
    unit_of_measurement: "h"
    accuracy_decimals: 1
    update_interval: 60s
    lambda: 'return id(bomba_horas_ayer);'

  # Home Assistant Input Entities - Configuration parameters
  - platform: homeassistant
    id: ha_temp_objetivo
    entity_id: input_number.pileta_temp_objetivo
    name: "HA Temperatura Objetivo (ITO)"
    on_value:
      then:
        - globals.set:
            id: temp_objetivo
            value: !lambda 'return x;'
        - logger.log:
            format: "Temperatura objetivo actualizada: %.1f°C"
            args: ['x']

  - platform: homeassistant
    id: ha_temp_max_diff
    entity_id: input_number.pileta_temp_max_diff
    name: "HA Temp Max Diff (IMX)"
    on_value:
      then:
        - lambda: |-
            float new_max_diff = x;
            float current_min_diff = id(temp_min_diff);
            float min_allowed = current_min_diff + 1.0;

            if (new_max_diff < min_allowed) {
              ESP_LOGW("safety", "IMX (%.1f) < IMI + 1 (%.1f). Forzando IMX = %.1f",
                       new_max_diff, min_allowed, min_allowed);
              id(temp_max_diff) = min_allowed;

              // Send notification (once per day)
              if (!id(notif_param_validation_sent)) {
                id(notif_param_validation_sent) = true;
                auto call = id(homeassistant_api).get_service("notify", "pushover");
                call.set_service_data("title", "Pool System Alert");
                call.set_service_data("message", "⚠️ Pool: IMX auto-corregido (ajustado a " + to_string(min_allowed) + "°C)");
                call.set_service_data("data", "{\"priority\": 0}");
                call.perform();
                ESP_LOGI("notifications", "Notificación enviada: Parámetro IMX auto-corregido");
              }
            } else {
              id(temp_max_diff) = new_max_diff;
            }

            ESP_LOGI("config", "Diferencia máxima actualizada: %.1f°C", id(temp_max_diff));

  - platform: homeassistant
    id: ha_temp_min_diff
    entity_id: input_number.pileta_temp_min_diff
    name: "HA Temp Min Diff (IMI)"
    on_value:
      then:
        - lambda: |-
            float new_min_diff = x;
            float current_max_diff = id(temp_max_diff);

            // Update IMI
            id(temp_min_diff) = new_min_diff;
            ESP_LOGI("config", "Diferencia mínima actualizada: %.1f°C", new_min_diff);

            // Check if IMX needs adjustment
            float min_allowed_max = new_min_diff + 1.0;
            if (current_max_diff < min_allowed_max) {
              ESP_LOGW("safety", "IMX (%.1f) < IMI + 1 (%.1f). Forzando IMX = %.1f",
                       current_max_diff, min_allowed_max, min_allowed_max);
              id(temp_max_diff) = min_allowed_max;
              ESP_LOGI("config", "Diferencia máxima ajustada a: %.1f°C", id(temp_max_diff));

              // Send notification (once per day)
              if (!id(notif_param_validation_sent)) {
                id(notif_param_validation_sent) = true;
                auto call = id(homeassistant_api).get_service("notify", "pushover");
                call.set_service_data("title", "Pool System Alert");
                call.set_service_data("message", "⚠️ Pool: IMX auto-corregido por cambio en IMI (ajustado a " + to_string(min_allowed_max) + "°C)");
                call.set_service_data("data", "{\"priority\": 0}");
                call.perform();
                ESP_LOGI("notifications", "Notificación enviada: Parámetro IMX auto-corregido (cambio IMI)");
              }
            }

# Text sensor for boolean input from HA
text_sensor:
  - platform: homeassistant
    id: ha_activar_calefaccion
    entity_id: input_boolean.activar_calefaccion_pileta
    name: "HA Activar Calefaccion (IAC)"
    on_value:
      then:
        - globals.set:
            id: calefaccion_habilitada
            value: !lambda |-
              return (x == "on" || x == "true");
        - logger.log:
            format: "Calefacción habilitada: %s"
            args: ['x.c_str()']

  - platform: homeassistant
    id: ha_activar_skimmer
    entity_id: input_boolean.activar_skimmer_pileta
    name: "HA Activar Skimmer (IAS)"
    on_value:
      then:
        - globals.set:
            id: skimmer_habilitado
            value: !lambda |-
              return (x == "on" || x == "true");
        - logger.log:
            format: "Skimmer habilitado: %s"
            args: ['x.c_str()']

# Global variables to store last known values for offline operation
globals:
  - id: calefaccion_habilitada
    type: bool
    restore_value: yes
    initial_value: 'false'

  - id: temp_objetivo
    type: float
    restore_value: yes
    initial_value: '28.0'

  - id: temp_max_diff
    type: float
    restore_value: yes
    initial_value: '5.0'

  - id: temp_min_diff
    type: float
    restore_value: yes
    initial_value: '2.0'

  - id: bomba_modo_calefaccion
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: bomba_horas_hoy
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: temp_agua_last_update
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: temp_calefactor_last_update
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: heating_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  # Skimmer automation globals
  - id: bomba_horas_ayer
    type: float
    restore_value: no
    initial_value: '0.0'

  - id: skimmer_habilitado
    type: bool
    restore_value: yes
    initial_value: 'false'

  - id: time_synced
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: skimmer_last_run
    type: unsigned long
    restore_value: no
    initial_value: '0'

  # Notification throttle flags (reset at midnight)
  - id: notif_sensor_water_range_sent
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: notif_sensor_heater_range_sent
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: notif_sensor_water_stale_sent
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: notif_sensor_heater_stale_sent
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: notif_pump_desync_sent
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: notif_watchdog_sent
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: notif_param_validation_sent
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: notif_test_available
    type: bool
    restore_value: no
    initial_value: 'true'


# Control logic - Evaluate heating conditions every 30 seconds
interval:
  - interval: 30s
    then:
      - lambda: |-
          // Get current values
          bool habilitada = id(calefaccion_habilitada);
          float temp_agua = id(temperatura_agua).state;
          float temp_calefactor = id(temperatura_calefactor).state;
          float objetivo = id(temp_objetivo);
          float max_diff = id(temp_max_diff);
          float min_diff = id(temp_min_diff);
          bool calefaccion_on = id(pileta_calefaccion_completa).state;
          unsigned long current_time = millis();

          // SAFETY CHECK 1: Check if we have valid sensor readings (NaN)
          if (isnan(temp_agua) || isnan(temp_calefactor)) {
            ESP_LOGW("safety", "Sensores no disponibles - esperando lecturas");
            if (calefaccion_on) {
              ESP_LOGE("safety", "Apagando calefacción por sensores inválidos");
              id(pileta_calefaccion_completa).turn_off();
            }
            return;
          }

          // SAFETY CHECK 2: Sensor range validation
          if (temp_agua < 0.0 || temp_agua > 50.0) {
            ESP_LOGE("safety", "Temperatura agua fuera de rango: %.1f°C", temp_agua);
            if (calefaccion_on) {
              ESP_LOGE("safety", "Apagando calefacción por sensor agua inválido");
              id(pileta_calefaccion_completa).turn_off();
            }

            // Send notification (once per day)
            if (!id(notif_sensor_water_range_sent)) {
              id(notif_sensor_water_range_sent) = true;
              auto call = id(homeassistant_api).get_service("notify", "pushover");
              call.set_service_data("title", "Pool System Alert");
              call.set_service_data("message", "⚠️ Pool: Sensor agua fuera de rango (" + to_string(temp_agua) + "°C)");
              call.set_service_data("data", "{\"priority\": 0}");
              call.perform();
              ESP_LOGI("notifications", "Notificación enviada: Sensor agua fuera de rango");
            }

            return;
          }
          if (temp_calefactor < 0.0 || temp_calefactor > 80.0) {
            ESP_LOGE("safety", "Temperatura calefactor fuera de rango: %.1f°C", temp_calefactor);
            if (calefaccion_on) {
              ESP_LOGE("safety", "Apagando calefacción por sensor calefactor inválido");
              id(pileta_calefaccion_completa).turn_off();
            }

            // Send notification (once per day)
            if (!id(notif_sensor_heater_range_sent)) {
              id(notif_sensor_heater_range_sent) = true;
              auto call = id(homeassistant_api).get_service("notify", "pushover");
              call.set_service_data("title", "Pool System Alert");
              call.set_service_data("message", "⚠️ Pool: Sensor calefactor fuera de rango (" + to_string(temp_calefactor) + "°C)");
              call.set_service_data("data", "{\"priority\": 0}");
              call.perform();
              ESP_LOGI("notifications", "Notificación enviada: Sensor calefactor fuera de rango");
            }

            return;
          }

          // SAFETY CHECK 3: Sensor staleness detection (5 minutes = 300000ms)
          if (id(temp_agua_last_update) > 0 &&
              (current_time - id(temp_agua_last_update)) > 300000) {
            ESP_LOGE("safety", "Sensor agua sin actualizar por >5 min");
            if (calefaccion_on) {
              ESP_LOGE("safety", "Apagando calefacción por sensor agua obsoleto");
              id(pileta_calefaccion_completa).turn_off();
            }

            // Send notification (once per day)
            if (!id(notif_sensor_water_stale_sent)) {
              id(notif_sensor_water_stale_sent) = true;
              auto call = id(homeassistant_api).get_service("notify", "pushover");
              call.set_service_data("title", "Pool System Alert");
              call.set_service_data("message", "⚠️ Pool: Sensor agua sin actualizar (>5 min)");
              call.set_service_data("data", "{\"priority\": 0}");
              call.perform();
              ESP_LOGI("notifications", "Notificación enviada: Sensor agua obsoleto");
            }

            return;
          }
          if (id(temp_calefactor_last_update) > 0 &&
              (current_time - id(temp_calefactor_last_update)) > 300000) {
            ESP_LOGE("safety", "Sensor calefactor sin actualizar por >5 min");
            if (calefaccion_on) {
              ESP_LOGE("safety", "Apagando calefacción por sensor calefactor obsoleto");
              id(pileta_calefaccion_completa).turn_off();
            }

            // Send notification (once per day)
            if (!id(notif_sensor_heater_stale_sent)) {
              id(notif_sensor_heater_stale_sent) = true;
              auto call = id(homeassistant_api).get_service("notify", "pushover");
              call.set_service_data("title", "Pool System Alert");
              call.set_service_data("message", "⚠️ Pool: Sensor calefactor sin actualizar (>5 min)");
              call.set_service_data("data", "{\"priority\": 0}");
              call.perform();
              ESP_LOGI("notifications", "Notificación enviada: Sensor calefactor obsoleto");
            }

            return;
          }

          // SAFETY CHECK 4: Pump state desync detection
          if (calefaccion_on && (!id(pileta_bomba_esp).state || !id(pileta_calefaccion_esp).state)) {
            ESP_LOGE("safety", "Desincronización detectada! Bomba=%s, Calefactor=%s",
                     id(pileta_bomba_esp).state ? "ON" : "OFF",
                     id(pileta_calefaccion_esp).state ? "ON" : "OFF");
            ESP_LOGE("safety", "Apagando sistema completo");
            id(pileta_calefaccion_completa).turn_off();

            // Send notification (once per day)
            if (!id(notif_pump_desync_sent)) {
              id(notif_pump_desync_sent) = true;
              auto call = id(homeassistant_api).get_service("notify", "pushover");
              call.set_service_data("title", "Pool System Alert");
              call.set_service_data("message", "⚠️ Pool: Desincronización de bombas detectada");
              call.set_service_data("data", "{\"priority\": 0}");
              call.perform();
              ESP_LOGI("notifications", "Notificación enviada: Desincronización de bombas");
            }

            return;
          }

          // SAFETY CHECK 5: Independent runtime watchdog (8 hours = 28800000ms)
          if (calefaccion_on && id(heating_start_time) > 0) {
            unsigned long runtime = current_time - id(heating_start_time);
            if (runtime > 28800000) {
              ESP_LOGE("safety", "Watchdog: 8 horas de operación alcanzadas");
              ESP_LOGE("safety", "Apagando por límite de tiempo independiente");
              id(pileta_calefaccion_completa).turn_off();

              // Send notification (once per day)
              if (!id(notif_watchdog_sent)) {
                id(notif_watchdog_sent) = true;
                auto call = id(homeassistant_api).get_service("notify", "pushover");
                call.set_service_data("title", "Pool System Alert");
                call.set_service_data("message", "⚠️ Pool: Límite de 8 horas alcanzado");
                call.set_service_data("data", "{\"priority\": 0}");
                call.perform();
                ESP_LOGI("notifications", "Notificación enviada: Watchdog 8 horas");
              }

              return;
            }
          }

          ESP_LOGD("control_logic", "Estado: IAC=%s, SAG=%.1f°C, SCL=%.1f°C, ITO=%.1f°C, IMX=%.1f°C, IMI=%.1f°C, Calef=%s",
                   habilitada ? "ON" : "OFF",
                   temp_agua,
                   temp_calefactor,
                   objetivo,
                   max_diff,
                   min_diff,
                   calefaccion_on ? "ON" : "OFF");

          // Turn OFF conditions (ANY condition triggers stop)
          bool should_turn_off = false;

          if (!habilitada) {
            ESP_LOGI("control_logic", "Apagar: IAC deshabilitada");
            should_turn_off = true;
          } else if (temp_agua >= objetivo) {
            ESP_LOGI("control_logic", "Apagar: Temperatura objetivo alcanzada (%.1f >= %.1f)", temp_agua, objetivo);
            should_turn_off = true;
          } else if (temp_calefactor <= (temp_agua + min_diff)) {
            ESP_LOGI("control_logic", "Apagar: Calefactor insuficiente (%.1f <= %.1f + %.1f)",
                     temp_calefactor, temp_agua, min_diff);
            should_turn_off = true;
          }

          if (should_turn_off && calefaccion_on) {
            ESP_LOGI("control_logic", ">>> APAGANDO CALEFACCION <<<");
            id(pileta_calefaccion_completa).turn_off();
            return;
          }

          // Turn ON conditions (ALL conditions must be true)
          bool should_turn_on = false;

          if (habilitada &&
              temp_agua < (objetivo - 0.5) &&  // Dead zone of 0.5°C
              temp_calefactor > (temp_agua + max_diff)) {
            should_turn_on = true;
            ESP_LOGI("control_logic", "Condiciones para encender cumplidas:");
            ESP_LOGI("control_logic", "  - IAC habilitada: SI");
            ESP_LOGI("control_logic", "  - SAG < (ITO - 0.5): %.1f < %.1f = SI", temp_agua, objetivo - 0.5);
            ESP_LOGI("control_logic", "  - SCL > (SAG + IMX): %.1f > %.1f = SI", temp_calefactor, temp_agua + max_diff);
          }

          if (should_turn_on && !calefaccion_on) {
            ESP_LOGI("control_logic", ">>> ENCENDIENDO CALEFACCION <<<");
            id(pileta_calefaccion_completa).turn_on();
            return;
          }

          // Log reason for not changing state
          if (!habilitada) {
            ESP_LOGD("control_logic", "No cambio: IAC deshabilitada");
          } else if (calefaccion_on) {
            ESP_LOGD("control_logic", "No cambio: Calefaccion ya encendida, condiciones para apagar no cumplidas");
          } else if (temp_agua >= (objetivo - 0.5)) {
            ESP_LOGD("control_logic", "No cambio: Temperatura cerca del objetivo (%.1f >= %.1f)",
                     temp_agua, objetivo - 0.5);
          } else if (temp_calefactor <= (temp_agua + max_diff)) {
            ESP_LOGD("control_logic", "No cambio: Calefactor insuficiente (%.1f <= %.1f)",
                     temp_calefactor, temp_agua + max_diff);
          }

  # Runtime tracking - Update pump hours counter every minute
  - interval: 60s
    then:
      - lambda: |-
          if (id(pileta_bomba_esp).state) {
            id(bomba_horas_hoy) += (1.0 / 60.0);  // Add 1/60 hour = 1 minute
            ESP_LOGD("runtime_tracker", "Bomba horas hoy: %.2f", id(bomba_horas_hoy));
          }

  # Skimmer fallback mode - Run every 12 hours if no time sync
  - interval: 60s
    then:
      - lambda: |-
          // Only run if time is NOT synced (fallback mode)
          if (id(time_synced)) {
            return;  // Scheduled mode is active, skip fallback
          }

          // Check if skimmer is enabled
          if (!id(skimmer_habilitado)) {
            return;
          }

          // Check if heating is active (heating has priority)
          if (id(bomba_modo_calefaccion)) {
            return;
          }

          // Check if 12 hours (43200000 ms) have elapsed since last run
          unsigned long current_time = millis();
          unsigned long time_since_last_run = current_time - id(skimmer_last_run);
          const unsigned long twelve_hours_ms = 43200000;  // 12 hours in milliseconds

          // Handle millis() overflow (wraps around every ~49 days)
          if (time_since_last_run >= twelve_hours_ms) {
            ESP_LOGI("skimmer", "=== Modo fallback: 12 horas transcurridas ===");
            ESP_LOGI("skimmer", "INICIANDO bomba (sin sincronización de tiempo)");
            id(pileta_bomba_esp).turn_on();
            id(skimmer_last_run) = current_time;
          } else {
            // Log remaining time every 30 minutes
            unsigned long remaining_ms = twelve_hours_ms - time_since_last_run;
            float remaining_hours = remaining_ms / 3600000.0;

            // Only log if we're at a 30-minute boundary (within a 60-second window)
            if (((int)(remaining_hours * 2) % 1 == 0) && (remaining_ms % 1800000 < 60000)) {
              ESP_LOGD("skimmer", "Fallback: %.1f horas hasta próximo ciclo", remaining_hours);
            }
          }

switch:
  - platform: gpio
    pin: GPIO2
    name: "Bomba pileta (ESP32)"
    id: pileta_bomba_esp
    on_turn_on:
      then:
        - logger.log: "Bomba pileta encendida - Temporizador 1 hora iniciado"
        - delay: 1h
        - if:
            condition:
              lambda: 'return !id(bomba_modo_calefaccion);'
            then:
              - switch.turn_off: pileta_bomba_esp
              - logger.log: "Bomba pileta apagada automáticamente después de 1 hora (modo skimmer)"
            else:
              - logger.log: "Auto-apagado de bomba omitido: controlada por modo calefacción"

  - platform: gpio
    pin: GPIO16
    name: "Calefaccion pileta (ESP32)"
    id: pileta_calefaccion_esp
    on_turn_on:
      then:
        - delay: 8h
        - switch.turn_off: pileta_calefaccion_esp
        - logger.log: "pileta_calefaccion_esp apagado automáticamente después de 8 horas."

  # Switch virtual: Modo calefacción (ambas bombas)
  - platform: template
    name: "Calefaccion Completa (ESP32)"
    id: pileta_calefaccion_completa
    lambda: |-
      // El switch está ON solo si AMBAS bombas están encendidas
      if (id(pileta_bomba_esp).state && id(pileta_calefaccion_esp).state) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - globals.set:
          id: bomba_modo_calefaccion
          value: 'true'
      - lambda: |-
          id(heating_start_time) = millis();
          ESP_LOGI("safety", "Watchdog iniciado - límite 8 horas");
      - logger.log: "Modo calefacción: activando flag de control"
      - switch.turn_on: pileta_bomba_esp
      - switch.turn_on: pileta_calefaccion_esp
      - logger.log: "Modo calefacción activado: ambas bombas encendidas"
      - delay: 8h
      - switch.turn_off: pileta_bomba_esp
      - switch.turn_off: pileta_calefaccion_esp
      - globals.set:
          id: bomba_modo_calefaccion
          value: 'false'
      - lambda: |-
          id(heating_start_time) = 0;
      - logger.log: "Modo calefacción apagado automáticamente después de 8 horas"
    turn_off_action:
      - globals.set:
          id: bomba_modo_calefaccion
          value: 'false'
      - lambda: |-
          id(heating_start_time) = 0;
      - logger.log: "Modo calefacción: desactivando flag de control"
      - switch.turn_off: pileta_bomba_esp
      - switch.turn_off: pileta_calefaccion_esp
      - logger.log: "Modo calefacción desactivado manualmente"

button:
  - platform: template
    name: "Test Pushover Notification"
    id: test_pushover_button
    icon: "mdi:bell-ring"
    on_press:
      then:
        - lambda: |-
            if (!id(notif_test_available)) {
              ESP_LOGW("notifications", "Test notification already sent today - wait for midnight reset");
              return;
            }
            ESP_LOGI("notifications", "Test button pressed - sending test notification");
            id(notif_test_available) = false;
        - homeassistant.service:
            service: notify.pushover
            data:
              title: "Pool System Test"
              message: "Test notification from ESP32-pileta. System operational."
              data:
                priority: 0
